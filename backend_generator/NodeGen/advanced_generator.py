from __future__ import annotations

import os
import json
import shutil
import tempfile
from dataclasses import dataclass
from typing import Dict, Any, List
from pathlib import Path

from ..ERD.models import ERDSchema, Entity, Attribute, DataType


@dataclass
class AdvancedGeneratedProject:
    output_dir: str
    project_name: str


class AdvancedNodeProjectGenerator:
    """Advanced Node.js backend generator with AI integration and comprehensive structure"""
    
    def __init__(self) -> None:
        pass

    def generate(self, erd_schema: ERDSchema) -> AdvancedGeneratedProject:
        """Generate advanced Node.js backend with comprehensive structure"""
        project_dir = tempfile.mkdtemp(prefix="codecraft_advanced_")
        project_name = erd_schema.project_name or "AdvancedBackend"
        
        # Create advanced project structure
        self._create_directory_structure(project_dir)
        self._write_package_json(project_dir)
        self._write_tsconfig(project_dir)
        self._write_env(project_dir)
        self._write_gitignore(project_dir)
        self._write_readme(project_dir, erd_schema)
        
        # Core application files
        self._write_server_js(project_dir)
        self._write_app_js(project_dir)
        
        # Configuration files
        self._write_config_files(project_dir)
        
        # Database files
        self._write_database_files(project_dir, erd_schema)
        
        # Models based on ERD
        self._write_models(project_dir, erd_schema)
        
        # Controllers based on ERD entities
        self._write_controllers(project_dir, erd_schema)
        
        # Routes based on ERD entities
        self._write_routes(project_dir, erd_schema)
        
        # Services based on ERD entities
        self._write_services(project_dir, erd_schema)
        
        # Middleware
        self._write_middleware(project_dir)
        
        # Utils
        self._write_utils(project_dir)
        
        # Tests
        self._write_tests(project_dir, erd_schema)
        
        # Documentation
        self._write_docs(project_dir, erd_schema)

        return AdvancedGeneratedProject(output_dir=project_dir, project_name=project_name)

    def _create_directory_structure(self, root: str) -> None:
        """Create comprehensive directory structure"""
        directories = [
            "src",
            "src/config",
            "src/routes", 
            "src/controllers",
            "src/models",
            "src/middleware",
            "src/services",
            "src/utils",
            "src/database",
            "src/database/migrations",
            "src/database/seeders",
            "src/tests",
            "src/docs"
        ]
        
        for directory in directories:
            os.makedirs(os.path.join(root, directory), exist_ok=True)

    def _write_package_json(self, root: str) -> None:
        """Write advanced package.json with comprehensive dependencies"""
        pkg = {
            "name": "codecraft-advanced-backend",
            "version": "1.0.0",
            "description": "Advanced Node.js backend generated by CodeCraft",
            "main": "src/server.js",
            "private": True,
            "scripts": {
                "dev": "nodemon --watch src --exec ts-node src/server.js",
                "build": "tsc",
                "start": "node dist/server.js",
                "test": "jest",
                "test:watch": "jest --watch",
                "lint": "eslint .",
                "lint:fix": "eslint . --fix",
                "migrate": "ts-node src/database/migrate.ts",
                "seed": "ts-node src/database/seed.ts"
            },
            "dependencies": {
                "express": "^4.19.2",
                "sequelize": "^6.37.3",
                "pg": "^8.13.1",
                "cors": "^2.8.5",
                "dotenv": "^16.4.5",
                "helmet": "^7.1.0",
                "morgan": "^1.10.0",
                "compression": "^1.7.4",
                "express-rate-limit": "^7.1.5",
                "bcryptjs": "^2.4.3",
                "jsonwebtoken": "^9.0.2",
                "joi": "^17.11.0",
                "express-validator": "^7.0.1",
                "winston": "^3.11.0",
                "swagger-ui-express": "^5.0.0",
                "yamljs": "^0.3.0"
            },
            "devDependencies": {
                "typescript": "^5.5.4",
                "ts-node": "^10.9.2",
                "nodemon": "^3.1.0",
                "@types/express": "^4.17.21",
                "@types/node": "^20.0.0",
                "@types/cors": "^2.8.17",
                "@types/compression": "^1.7.5",
                "@types/bcryptjs": "^2.4.6",
                "@types/jsonwebtoken": "^9.0.5",
                "@types/morgan": "^1.9.9",
                "@types/swagger-ui-express": "^4.1.6",
                "jest": "^29.7.0",
                "@types/jest": "^29.5.12",
                "eslint": "^8.57.0",
                "@typescript-eslint/eslint-plugin": "^6.21.0",
                "@typescript-eslint/parser": "^6.21.0"
            }
        }
        os.makedirs(root, exist_ok=True)
        with open(os.path.join(root, "package.json"), "w", encoding="utf-8") as f:
            json.dump(pkg, f, indent=2)

    def _write_tsconfig(self, root: str) -> None:
        """Write TypeScript configuration"""
        tsconfig = {
            "compilerOptions": {
                "target": "ES2020",
                "module": "CommonJS",
                "moduleResolution": "Node",
                "outDir": "dist",
                "rootDir": "src",
                "esModuleInterop": True,
                "allowSyntheticDefaultImports": True,
                "forceConsistentCasingInFileNames": True,
                "skipLibCheck": True,
                "strict": True,
                "noImplicitAny": True,
                "strictNullChecks": True,
                "strictFunctionTypes": True,
                "noImplicitReturns": True,
                "noFallthroughCasesInSwitch": True,
                "noUncheckedIndexedAccess": True,
                "exactOptionalPropertyTypes": True
            },
            "include": ["src/**/*"],
            "exclude": ["node_modules", "dist", "tests"],
            "ts-node": {
                "esm": False
            }
        }
        with open(os.path.join(root, "tsconfig.json"), "w", encoding="utf-8") as f:
            json.dump(tsconfig, f, indent=2)

    def _write_env(self, root: str) -> None:
        """Write comprehensive environment configuration"""
        env_content = """# Database Configuration
DATABASE_URL=postgres://user:password@localhost:5432/advanced_backend
DB_HOST=localhost
DB_PORT=5432
DB_NAME=advanced_backend
DB_USER=user
DB_PASSWORD=password

# Server Configuration
PORT=3000
NODE_ENV=development

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRES_IN=24h

# CORS Configuration
CORS_ORIGIN=http://localhost:3000

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Logging
LOG_LEVEL=info
LOG_FILE=logs/app.log

# Email Configuration (for future use)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password

# Redis Configuration (for future use)
REDIS_URL=redis://localhost:6379

# File Upload
MAX_FILE_SIZE=10485760
UPLOAD_PATH=uploads/
"""
        with open(os.path.join(root, ".env"), "w", encoding="utf-8") as f:
            f.write(env_content)

    def _write_gitignore(self, root: str) -> None:
        """Write comprehensive .gitignore"""
        gitignore_content = """# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage
.grunt

# Bower dependency directory
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons
build/Release

# Dependency directories
jspm_packages/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test
.env.production

# parcel-bundler cache
.cache
.parcel-cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
public

# Storybook build outputs
.out
.storybook-out

# Temporary folders
tmp/
temp/

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# Grunt intermediate storage
.grunt

# Bower dependency directory
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# IDE files
.vscode/
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Uploads
uploads/
"""
        with open(os.path.join(root, ".gitignore"), "w", encoding="utf-8") as f:
            f.write(gitignore_content)

    def _write_readme(self, root: str, erd_schema: ERDSchema) -> None:
        """Write comprehensive README"""
        entities_list = "\n".join([f"- {entity.name}" for entity in erd_schema.entities])
        endpoints_list = "\n".join([f"- GET/POST/PUT/DELETE /api/{entity.table_name or self._to_snake(entity.name)}" for entity in erd_schema.entities])
        
        readme_content = f"""# {erd_schema.project_name or 'Advanced Backend'}

Generated by CodeCraft Advanced Backend Generator with AI integration.

## ðŸš€ Features

- **Advanced Architecture**: Professional Node.js/Express structure
- **TypeScript Support**: Full type safety and modern JavaScript features
- **Database Integration**: Sequelize ORM with PostgreSQL
- **Security**: Helmet, CORS, rate limiting, input validation
- **Logging**: Winston logger with file and console output
- **Testing**: Jest testing framework with examples
- **Documentation**: Auto-generated API docs with Swagger
- **Middleware**: Authentication, error handling, request logging
- **Services**: Business logic separation
- **Migrations**: Database schema management
- **Seeders**: Sample data generation

## ðŸ“ Project Structure

```
project-root/
â”œâ”€â”€ ðŸ“„ package.json
â”œâ”€â”€ ðŸ“„ tsconfig.json
â”œâ”€â”€ ðŸ“„ .env
â”œâ”€â”€ ðŸ“„ .gitignore
â”œâ”€â”€ ðŸ“„ README.md
â”œâ”€â”€ ðŸ“‚ src/
â”‚   â”œâ”€â”€ ðŸ“„ server.js          # Application entry point
â”‚   â”œâ”€â”€ ðŸ“„ app.js             # Express app configuration
â”‚   â”œâ”€â”€ ðŸ“‚ config/            # Configuration files
â”‚   â”‚   â”œâ”€â”€ db.js             # Database configuration
â”‚   â”‚   â”œâ”€â”€ logger.js         # Logging configuration
â”‚   â”‚   â””â”€â”€ env.js            # Environment variables
â”‚   â”œâ”€â”€ ðŸ“‚ routes/            # API routes
â”‚   â”‚   â”œâ”€â”€ index.js          # Main router
â”‚   â”‚   â”œâ”€â”€ user.routes.js    # User routes
â”‚   â”‚   â””â”€â”€ auth.routes.js    # Authentication routes
â”‚   â”œâ”€â”€ ðŸ“‚ controllers/        # Route controllers
â”‚   â”‚   â”œâ”€â”€ user.controller.js
â”‚   â”‚   â””â”€â”€ auth.controller.js
â”‚   â”œâ”€â”€ ðŸ“‚ models/            # Database models
â”‚   â”‚   â”œâ”€â”€ user.model.js
â”‚   â”‚   â””â”€â”€ product.model.js
â”‚   â”œâ”€â”€ ðŸ“‚ middleware/        # Custom middleware
â”‚   â”‚   â”œâ”€â”€ auth.middleware.js
â”‚   â”‚   â”œâ”€â”€ error.middleware.js
â”‚   â”‚   â””â”€â”€ notFound.middleware.js
â”‚   â”œâ”€â”€ ðŸ“‚ services/          # Business logic
â”‚   â”‚   â”œâ”€â”€ user.service.js
â”‚   â”‚   â””â”€â”€ email.service.js
â”‚   â”œâ”€â”€ ðŸ“‚ utils/             # Utility functions
â”‚   â”‚   â”œâ”€â”€ helpers.js
â”‚   â”‚   â”œâ”€â”€ constants.js
â”‚   â”‚   â””â”€â”€ validators.js
â”‚   â”œâ”€â”€ ðŸ“‚ database/          # Database management
â”‚   â”‚   â”œâ”€â”€ migrations/
â”‚   â”‚   â”œâ”€â”€ seeders/
â”‚   â”‚   â””â”€â”€ index.js
â”‚   â”œâ”€â”€ ðŸ“‚ tests/             # Test files
â”‚   â”‚   â”œâ”€â”€ user.test.js
â”‚   â”‚   â””â”€â”€ auth.test.js
â”‚   â””â”€â”€ ðŸ“‚ docs/              # Documentation
â”‚       â””â”€â”€ api-docs.yaml
```

## ðŸ› ï¸ Getting Started

### Prerequisites

- Node.js (v18 or higher)
- PostgreSQL (v12 or higher)
- npm or yarn

### Installation

1. **Install dependencies:**
   ```bash
   npm install
   ```

2. **Set up environment variables:**
   ```bash
   cp .env.example .env
   # Edit .env with your database credentials
   ```

3. **Set up the database:**
   ```bash
   # Create PostgreSQL database
   createdb advanced_backend
   
   # Run migrations
   npm run migrate
   
   # Seed the database (optional)
   npm run seed
   ```

4. **Start the development server:**
   ```bash
   npm run dev
   ```

5. **Build for production:**
   ```bash
   npm run build
   npm start
   ```

## ðŸ“Š Database Schema

### Entities:
{entities_list}

### Generated Endpoints:
{endpoints_list}

## ðŸ”§ Configuration

### Environment Variables

- `DATABASE_URL`: PostgreSQL connection string
- `PORT`: Server port (default: 3000)
- `JWT_SECRET`: Secret key for JWT tokens
- `NODE_ENV`: Environment (development/production)

### Database Configuration

The application uses Sequelize ORM with PostgreSQL. All models are automatically generated based on your ERD schema.

## ðŸ§ª Testing

```bash
# Run all tests
npm test

# Run tests in watch mode
npm run test:watch

# Run tests with coverage
npm test -- --coverage
```

## ðŸ“š API Documentation

Once the server is running, visit:
- **Swagger UI**: http://localhost:3000/api-docs
- **API JSON**: http://localhost:3000/api-docs.json

## ðŸ”’ Security Features

- **Helmet**: Security headers
- **CORS**: Cross-origin resource sharing
- **Rate Limiting**: Request rate limiting
- **Input Validation**: Joi validation schemas
- **Authentication**: JWT-based authentication
- **Password Hashing**: bcryptjs for password security

## ðŸ“ Logging

The application uses Winston for logging:
- Console output for development
- File logging for production
- Different log levels (error, warn, info, debug)

## ðŸš€ Deployment

### Docker (Recommended)

```bash
# Build Docker image
docker build -t advanced-backend .

# Run container
docker run -p 3000:3000 advanced-backend
```

### Manual Deployment

1. Build the application:
   ```bash
   npm run build
   ```

2. Set production environment variables

3. Start the application:
   ```bash
   npm start
   ```

## ðŸ¤ Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests
5. Submit a pull request

## ðŸ“„ License

This project is licensed under the MIT License.

## ðŸ†˜ Support

For support and questions:
- Create an issue in the repository
- Check the documentation
- Review the API endpoints

---

**Generated by CodeCraft Advanced Backend Generator** ðŸš€
"""
        with open(os.path.join(root, "README.md"), "w", encoding="utf-8") as f:
            f.write(readme_content)

    def _write_server_js(self, root: str) -> None:
        """Write server.js entry point"""
        server_content = """import dotenv from 'dotenv';
import { createServer } from './app.js';
import { logger } from './config/logger.js';

// Load environment variables
dotenv.config();

const PORT = process.env.PORT || 3000;
const NODE_ENV = process.env.NODE_ENV || 'development';

async function startServer() {
    try {
        const app = createServer();
        
        app.listen(PORT, () => {
            logger.info(`ðŸš€ Server running on port ${PORT}`);
            logger.info(`ðŸŒ Environment: ${NODE_ENV}`);
            logger.info(`ðŸ“š API Documentation: http://localhost:${PORT}/api-docs`);
        });
    } catch (error) {
        logger.error('Failed to start server:', error);
        process.exit(1);
    }
}

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
    logger.error('Uncaught Exception:', error);
    process.exit(1);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
    logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
    process.exit(1);
});

// Graceful shutdown
process.on('SIGTERM', () => {
    logger.info('SIGTERM received, shutting down gracefully');
    process.exit(0);
});

process.on('SIGINT', () => {
    logger.info('SIGINT received, shutting down gracefully');
    process.exit(0);
});

startServer();
"""
        with open(os.path.join(root, "src", "server.js"), "w", encoding="utf-8") as f:
            f.write(server_content)

    def _write_app_js(self, root: str) -> None:
        """Write app.js with advanced middleware setup"""
        app_content = """import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import compression from 'compression';
import rateLimit from 'express-rate-limit';
import swaggerUi from 'swagger-ui-express';
import YAML from 'yamljs';

import { logger } from './config/logger.js';
import { errorHandler } from './middleware/error.middleware.js';
import { notFoundHandler } from './middleware/notFound.middleware.js';
import routes from './routes/index.js';

// Load Swagger documentation
const swaggerDocument = YAML.load('./src/docs/api-docs.yaml');

export function createServer() {
    const app = express();
    
    // Security middleware
    app.use(helmet({
        contentSecurityPolicy: {
            directives: {
                defaultSrc: ["'self'"],
                styleSrc: ["'self'", "'unsafe-inline'"],
                scriptSrc: ["'self'"],
                imgSrc: ["'self'", "data:", "https:"],
            },
        },
    }));
    
    // CORS configuration
    app.use(cors({
        origin: process.env.CORS_ORIGIN || 'http://localhost:3000',
        credentials: true,
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
    }));
    
    // Compression middleware
    app.use(compression());
    
    // Rate limiting
    const limiter = rateLimit({
        windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutes
        max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100, // limit each IP to 100 requests per windowMs
        message: {
            error: 'Too many requests from this IP, please try again later.',
        },
        standardHeaders: true,
        legacyHeaders: false,
    });
    app.use(limiter);
    
    // Logging middleware
    app.use(morgan('combined', {
        stream: {
            write: (message) => logger.info(message.trim()),
        },
    }));
    
    // Body parsing middleware
    app.use(express.json({ limit: '10mb' }));
    app.use(express.urlencoded({ extended: true, limit: '10mb' }));
    
    // API Documentation
    app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument, {
        customCss: '.swagger-ui .topbar { display: none }',
        customSiteTitle: 'Advanced Backend API Documentation',
    }));
    
    // Health check endpoint
    app.get('/health', (req, res) => {
        res.json({
            status: 'OK',
            timestamp: new Date().toISOString(),
            uptime: process.uptime(),
            environment: process.env.NODE_ENV,
        });
    });
    
    // API routes
    app.use('/api', routes);
    
    // Root endpoint
    app.get('/', (req, res) => {
        res.json({
            message: 'Welcome to Advanced Backend API',
            version: '1.0.0',
            documentation: '/api-docs',
            health: '/health',
        });
    });
    
    // Error handling middleware (must be last)
    app.use(notFoundHandler);
    app.use(errorHandler);
    
    return app;
}
"""
        with open(os.path.join(root, "src", "app.js"), "w", encoding="utf-8") as f:
            f.write(app_content)

    def _write_config_files(self, root: str) -> None:
        """Write configuration files"""
        # Database configuration
        db_content = """import { Sequelize } from 'sequelize';
import { logger } from './logger.js';

const sequelize = new Sequelize(
    process.env.DATABASE_URL || 'postgres://user:password@localhost:5432/advanced_backend',
    {
        dialect: 'postgres',
        logging: (msg) => logger.debug(msg),
        pool: {
            max: 5,
            min: 0,
            acquire: 30000,
            idle: 10000,
        },
        define: {
            timestamps: true,
            underscored: true,
            freezeTableName: true,
        },
    }
);

// Test database connection
export async function testConnection() {
    try {
        await sequelize.authenticate();
        logger.info('âœ… Database connection established successfully');
        return true;
    } catch (error) {
        logger.error('âŒ Unable to connect to database:', error);
        return false;
    }
}

export { sequelize };
"""
        with open(os.path.join(root, "src", "config", "db.js"), "w", encoding="utf-8") as f:
            f.write(db_content)

        # Logger configuration
        logger_content = """import winston from 'winston';
import path from 'path';

const { combine, timestamp, errors, json, printf, colorize } = winston.format;

// Custom format for console output
const consoleFormat = printf(({ level, message, timestamp, stack }) => {
    return `${timestamp} [${level}]: ${stack || message}`;
});

// Create logger instance
export const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: combine(
        timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
        errors({ stack: true }),
        json()
    ),
    defaultMeta: { service: 'advanced-backend' },
    transports: [
        // Console transport
        new winston.transports.Console({
            format: combine(
                colorize(),
                timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
                consoleFormat
            ),
        }),
        // File transport for errors
        new winston.transports.File({
            filename: 'logs/error.log',
            level: 'error',
            maxsize: 5242880, // 5MB
            maxFiles: 5,
        }),
        // File transport for all logs
        new winston.transports.File({
            filename: 'logs/combined.log',
            maxsize: 5242880, // 5MB
            maxFiles: 5,
        }),
    ],
});

// Create logs directory if it doesn't exist
import fs from 'fs';
const logsDir = 'logs';
if (!fs.existsSync(logsDir)) {
    fs.mkdirSync(logsDir);
}
"""
        with open(os.path.join(root, "src", "config", "logger.js"), "w", encoding="utf-8") as f:
            f.write(logger_content)

        # Environment configuration
        env_config_content = """import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

export const config = {
    // Server configuration
    port: process.env.PORT || 3000,
    nodeEnv: process.env.NODE_ENV || 'development',
    
    // Database configuration
    database: {
        url: process.env.DATABASE_URL || 'postgres://user:password@localhost:5432/advanced_backend',
        host: process.env.DB_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT) || 5432,
        name: process.env.DB_NAME || 'advanced_backend',
        user: process.env.DB_USER || 'user',
        password: process.env.DB_PASSWORD || 'password',
    },
    
    // JWT configuration
    jwt: {
        secret: process.env.JWT_SECRET || 'your-super-secret-jwt-key',
        expiresIn: process.env.JWT_EXPIRES_IN || '24h',
    },
    
    // CORS configuration
    cors: {
        origin: process.env.CORS_ORIGIN || 'http://localhost:3000',
    },
    
    // Rate limiting
    rateLimit: {
        windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 900000, // 15 minutes
        maxRequests: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100,
    },
    
    // Logging
    logging: {
        level: process.env.LOG_LEVEL || 'info',
        file: process.env.LOG_FILE || 'logs/app.log',
    },
    
    // Email configuration
    email: {
        smtp: {
            host: process.env.SMTP_HOST || 'smtp.gmail.com',
            port: parseInt(process.env.SMTP_PORT) || 587,
            user: process.env.SMTP_USER || '',
            pass: process.env.SMTP_PASS || '',
        },
    },
    
    // File upload
    upload: {
        maxFileSize: parseInt(process.env.MAX_FILE_SIZE) || 10485760, // 10MB
        uploadPath: process.env.UPLOAD_PATH || 'uploads/',
    },
};
"""
        with open(os.path.join(root, "src", "config", "env.js"), "w", encoding="utf-8") as f:
            f.write(env_config_content)

    def _write_database_files(self, root: str, erd_schema: ERDSchema) -> None:
        """Write database management files"""
        # Database index
        db_index_content = """import { sequelize } from './config/db.js';
import { logger } from './config/logger.js';

// Import all models
// Models will be imported here when they are created

export async function syncDatabase() {
    try {
        await sequelize.sync({ force: false });
        logger.info('âœ… Database synchronized successfully');
    } catch (error) {
        logger.error('âŒ Database synchronization failed:', error);
        throw error;
    }
}

export async function closeDatabase() {
    try {
        await sequelize.close();
        logger.info('âœ… Database connection closed');
    } catch (error) {
        logger.error('âŒ Error closing database connection:', error);
        throw error;
    }
}
"""
        with open(os.path.join(root, "src", "database", "index.js"), "w", encoding="utf-8") as f:
            f.write(db_index_content)

        # Migration file
        migrate_content = """import { sequelize } from '../config/db.js';
import { logger } from '../config/logger.js';

async function migrate() {
    try {
        await sequelize.sync({ force: false });
        logger.info('âœ… Migration completed successfully');
        process.exit(0);
    } catch (error) {
        logger.error('âŒ Migration failed:', error);
        process.exit(1);
    }
}

migrate();
"""
        with open(os.path.join(root, "src", "database", "migrate.js"), "w", encoding="utf-8") as f:
            f.write(migrate_content)

        # Seeder file
        seed_content = """import { sequelize } from '../config/db.js';
import { logger } from '../config/logger.js';

async function seed() {
    try {
        // Add seed data here
        logger.info('âœ… Database seeded successfully');
        process.exit(0);
    } catch (error) {
        logger.error('âŒ Seeding failed:', error);
        process.exit(1);
    }
}

seed();
"""
        with open(os.path.join(root, "src", "database", "seed.js"), "w", encoding="utf-8") as f:
            f.write(seed_content)

    def _write_models(self, root: str, erd_schema: ERDSchema) -> None:
        """Write model files based on ERD entities"""
        for entity in erd_schema.entities:
            model_name = entity.name.lower()
            model_content = f"""import {{ DataTypes }} from 'sequelize';
import {{ sequelize }} from '../config/db.js';

const {entity.name} = sequelize.define('{entity.name}', {{
"""
            
            # Add attributes
            for attr in entity.attributes:
                field_name = attr.name
                field_type = self._sequelize_type(attr.data_type)
                field_config = f"    {field_name}: {{\n"
                field_config += f"        type: {field_type},\n"
                
                if attr.is_primary_key:
                    field_config += "        primaryKey: true,\n"
                if attr.is_unique:
                    field_config += "        unique: true,\n"
                if not attr.is_nullable:
                    field_config += "        allowNull: false,\n"
                if hasattr(attr, 'max_length') and attr.max_length:
                    field_config += f"        validate: {{\n"
                    field_config += f"            len: [0, {attr.max_length}]\n"
                    field_config += f"        }},\n"
                
                field_config += "    },"
                model_content += field_config + "\n"
            
            model_content += f"""}}, {{
    timestamps: true,
    tableName: '{entity.table_name or self._to_snake(entity.name)}',
    underscored: true,
}});

export default {entity.name};
"""
            
            with open(os.path.join(root, "src", "models", f"{model_name}.model.js"), "w", encoding="utf-8") as f:
                f.write(model_content)

    def _write_controllers(self, root: str, erd_schema: ERDSchema) -> None:
        """Write controller files based on ERD entities"""
        for entity in erd_schema.entities:
            controller_name = entity.name.lower()
            controller_content = f"""import {entity.name} from '../models/{controller_name}.model.js';
import {{ logger }} from '../config/logger.js';

export class {entity.name}Controller {{
    // Get all {entity.name.lower()}s
    static async getAll(req, res) {{
        try {{
            const {{ page = 1, limit = 10, sortBy = 'createdAt', sortOrder = 'DESC' }} = req.query;
            const offset = (page - 1) * limit;
            
            const {{ count, rows }} = await {entity.name}.findAndCountAll({{
                limit: parseInt(limit),
                offset: parseInt(offset),
                order: [[sortBy, sortOrder.toUpperCase()]],
            }});
            
            res.json({{
                success: true,
                data: rows,
                pagination: {{
                    page: parseInt(page),
                    limit: parseInt(limit),
                    total: count,
                    pages: Math.ceil(count / limit),
                }},
            }});
        }} catch (error) {{
            logger.error('Error fetching {entity.name.lower()}s:', error);
            res.status(500).json({{
                success: false,
                message: 'Internal server error',
            }});
        }}
    }}

    // Get {entity.name.lower()} by ID
    static async getById(req, res) {{
        try {{
            const {{ id }} = req.params;
            const {entity.name.lower()} = await {entity.name}.findByPk(id);
            
            if (!{entity.name.lower()}) {{
                return res.status(404).json({{
                    success: false,
                    message: '{entity.name} not found',
                }});
            }}
            
            res.json({{
                success: true,
                data: {entity.name.lower()},
            }});
        }} catch (error) {{
            logger.error('Error fetching {entity.name.lower()}:', error);
            res.status(500).json({{
                success: false,
                message: 'Internal server error',
            }});
        }}
    }}

    // Create new {entity.name.lower()}
    static async create(req, res) {{
        try {{
            const {entity.name.lower()} = await {entity.name}.create(req.body);
            res.status(201).json({{
                success: true,
                data: {entity.name.lower()},
                message: '{entity.name} created successfully',
            }});
        }} catch (error) {{
            logger.error('Error creating {entity.name.lower()}:', error);
            res.status(500).json({{
                success: false,
                message: 'Internal server error',
            }});
        }}
    }}

    // Update {entity.name.lower()}
    static async update(req, res) {{
        try {{
            const {{ id }} = req.params;
            const {entity.name.lower()} = await {entity.name}.findByPk(id);
            
            if (!{entity.name.lower()}) {{
                return res.status(404).json({{
                    success: false,
                    message: '{entity.name} not found',
                }});
            }}
            
            await {entity.name.lower()}.update(req.body);
            await {entity.name.lower()}.reload();
            
            res.json({{
                success: true,
                data: {entity.name.lower()},
                message: '{entity.name} updated successfully',
            }});
        }} catch (error) {{
            logger.error('Error updating {entity.name.lower()}:', error);
            res.status(500).json({{
                success: false,
                message: 'Internal server error',
            }});
        }}
    }}

    // Delete {entity.name.lower()}
    static async delete(req, res) {{
        try {{
            const {{ id }} = req.params;
            const {entity.name.lower()} = await {entity.name}.findByPk(id);
            
            if (!{entity.name.lower()}) {{
                return res.status(404).json({{
                    success: false,
                    message: '{entity.name} not found',
                }});
            }}
            
            await {entity.name.lower()}.destroy();
            
            res.json({{
                success: true,
                message: '{entity.name} deleted successfully',
            }});
        }} catch (error) {{
            logger.error('Error deleting {entity.name.lower()}:', error);
            res.status(500).json({{
                success: false,
                message: 'Internal server error',
            }});
        }}
    }}
}}
"""
            
            with open(os.path.join(root, "src", "controllers", f"{controller_name}.controller.js"), "w", encoding="utf-8") as f:
                f.write(controller_content)

    def _write_routes(self, root: str, erd_schema: ERDSchema) -> None:
        """Write route files based on ERD entities"""
        # Main routes index
        routes_content = """import express from 'express';
import { logger } from '../config/logger.js';

const router = express.Router();

// Import entity routes
"""
        
        # Add entity routes
        for entity in erd_schema.entities:
            route_name = entity.name.lower()
            routes_content += f"import {entity.name}Routes from './{route_name}.routes.js';\n"
        
        routes_content += """
// Health check route
router.get('/health', (req, res) => {
    res.json({
        success: true,
        message: 'API is healthy',
        timestamp: new Date().toISOString()
    });
});

// Mount entity routes
"""
        
        # Add entity route mounting
        for entity in erd_schema.entities:
            route_name = entity.name.lower()
            routes_content += f"router.use('/{route_name}', {entity.name}Routes);\n"
        
        routes_content += """
export default router;
"""
        
        with open(os.path.join(routes_dir, "index.js"), "w", encoding="utf-8") as f:
            f.write(routes_content)

    def _write_services(self, root: str, erd_schema: ERDSchema) -> None:
        """Write service files based on ERD entities"""
        services_dir = os.path.join(root, "src", "services")
        os.makedirs(services_dir, exist_ok=True)
        
        for entity in erd_schema.entities:
            service_name = entity.name.lower()
            service_content = f"""const {entity.name} = require('../models/{service_name}.model');
const logger = require('../config/logger');

class {entity.name}Service {{
    // Get all {entity.name.lower()}s with pagination
    static async getAll(page = 1, limit = 10) {{
        try {{
            const offset = (page - 1) * limit;
            const {{ count, rows }} = await {entity.name}.findAndCountAll({{
                limit,
                offset,
                order: [['createdAt', 'DESC']]
            }});
            
            return {{
                success: true,
                data: rows,
                pagination: {{
                    page,
                    limit,
                    total: count,
                    pages: Math.ceil(count / limit)
                }}
            }};
        }} catch (error) {{
            logger.error('Error in {entity.name}Service.getAll:', error);
            throw error;
        }}
    }}

    // Get {entity.name.lower()} by ID
    static async getById(id) {{
        try {{
            const {entity.name.lower()} = await {entity.name}.findByPk(id);
            if (!{entity.name.lower()}) {{
                throw new Error('{entity.name} not found');
            }}
            return {{ success: true, data: {entity.name.lower()} }};
        }} catch (error) {{
            logger.error('Error in {entity.name}Service.getById:', error);
            throw error;
        }}
    }}

    // Create new {entity.name.lower()}
    static async create(data) {{
        try {{
            const {entity.name.lower()} = await {entity.name}.create(data);
            return {{ success: true, data: {entity.name.lower()} }};
        }} catch (error) {{
            logger.error('Error in {entity.name}Service.create:', error);
            throw error;
        }}
    }}

    // Update {entity.name.lower()}
    static async update(id, data) {{
        try {{
            const {entity.name.lower()} = await {entity.name}.findByPk(id);
            if (!{entity.name.lower()}) {{
                throw new Error('{entity.name} not found');
            }}
            
            await {entity.name.lower()}.update(data);
            return {{ success: true, data: {entity.name.lower()} }};
        }} catch (error) {{
            logger.error('Error in {entity.name}Service.update:', error);
            throw error;
        }}
    }}

    // Delete {entity.name.lower()}
    static async delete(id) {{
        try {{
            const {entity.name.lower()} = await {entity.name}.findByPk(id);
            if (!{entity.name.lower()}) {{
                throw new Error('{entity.name} not found');
            }}
            
            await {entity.name.lower()}.destroy();
            return {{ success: true, message: '{entity.name} deleted successfully' }};
        }} catch (error) {{
            logger.error('Error in {entity.name}Service.delete:', error);
            throw error;
        }}
    }}
}}

module.exports = {entity.name}Service;
"""
            
            with open(os.path.join(services_dir, f"{service_name}.service.js"), "w", encoding="utf-8") as f:
                f.write(service_content)

    def _write_middleware(self, root: str) -> None:
        """Write middleware files"""
        middleware_dir = os.path.join(root, "src", "middleware")
        os.makedirs(middleware_dir, exist_ok=True)
        
        # Auth middleware
        auth_content = """const jwt = require('jsonwebtoken');
const { logger } = require('../config/logger');

const authMiddleware = (req, res, next) => {
    try {
        const token = req.header('Authorization')?.replace('Bearer ', '');
        
        if (!token) {
            return res.status(401).json({
                success: false,
                message: 'Access denied. No token provided.'
            });
        }
        
        const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key');
        req.user = decoded;
        next();
    } catch (error) {
        logger.error('Auth middleware error:', error);
        res.status(401).json({
            success: false,
            message: 'Invalid token.'
        });
    }
};

module.exports = authMiddleware;
"""
        
        with open(os.path.join(middleware_dir, "auth.middleware.js"), "w", encoding="utf-8") as f:
            f.write(auth_content)
        
        # Error middleware
        error_content = """const { logger } = require('../config/logger');

const errorMiddleware = (err, req, res, next) => {
    logger.error('Error:', err);
    
    // Sequelize validation errors
    if (err.name === 'SequelizeValidationError') {
        return res.status(400).json({
            success: false,
            message: 'Validation error',
            errors: err.errors.map(e => ({
                field: e.path,
                message: e.message
            }))
        });
    }
    
    // Sequelize unique constraint errors
    if (err.name === 'SequelizeUniqueConstraintError') {
        return res.status(400).json({
            success: false,
            message: 'Duplicate entry',
            field: err.errors[0].path
        });
    }
    
    // Default error
    res.status(err.status || 500).json({
        success: false,
        message: err.message || 'Internal server error'
    });
};

module.exports = errorMiddleware;
"""
        
        with open(os.path.join(middleware_dir, "error.middleware.js"), "w", encoding="utf-8") as f:
            f.write(error_content)
        
        # Not found middleware
        not_found_content = """const notFoundMiddleware = (req, res) => {
    res.status(404).json({
        success: false,
        message: `Route ${req.originalUrl} not found`
    });
};

module.exports = notFoundMiddleware;
"""
        
        with open(os.path.join(middleware_dir, "notFound.middleware.js"), "w", encoding="utf-8") as f:
            f.write(not_found_content)

    def _write_utils(self, root: str) -> None:
        """Write utility files"""
        utils_dir = os.path.join(root, "src", "utils")
        os.makedirs(utils_dir, exist_ok=True)
        
        # Helpers
        helpers_content = """const crypto = require('crypto');

// Generate random string
const generateRandomString = (length = 32) => {
    return crypto.randomBytes(length).toString('hex');
};

// Format date
const formatDate = (date) => {
    return new Date(date).toISOString();
};

// Validate email
const isValidEmail = (email) => {
    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
    return emailRegex.test(email);
};

// Sanitize string
const sanitizeString = (str) => {
    return str.trim().replace(/[<>]/g, '');
};

// Generate slug
const generateSlug = (text) => {
    return text
        .toLowerCase()
        .replace(/[^a-z0-9 -]/g, '')
        .replace(/\\s+/g, '-')
        .replace(/-+/g, '-')
        .trim('-');
};

module.exports = {
    generateRandomString,
    formatDate,
    isValidEmail,
    sanitizeString,
    generateSlug
};
"""
        
        with open(os.path.join(utils_dir, "helpers.js"), "w", encoding="utf-8") as f:
            f.write(helpers_content)
        
        # Constants
        constants_content = """// HTTP Status Codes
const HTTP_STATUS = {
    OK: 200,
    CREATED: 201,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    CONFLICT: 409,
    INTERNAL_SERVER_ERROR: 500
};

// Response Messages
const MESSAGES = {
    SUCCESS: 'Operation completed successfully',
    ERROR: 'An error occurred',
    NOT_FOUND: 'Resource not found',
    UNAUTHORIZED: 'Unauthorized access',
    VALIDATION_ERROR: 'Validation failed'
};

// Pagination
const PAGINATION = {
    DEFAULT_PAGE: 1,
    DEFAULT_LIMIT: 10,
    MAX_LIMIT: 100
};

module.exports = {
    HTTP_STATUS,
    MESSAGES,
    PAGINATION
};
"""
        
        with open(os.path.join(utils_dir, "constants.js"), "w", encoding="utf-8") as f:
            f.write(constants_content)
        
        # Validators
        validators_content = """const Joi = require('joi');

// Common validation schemas
const commonSchemas = {
    id: Joi.number().integer().positive().required(),
    email: Joi.string().email().required(),
    password: Joi.string().min(6).required(),
    name: Joi.string().min(2).max(100).required(),
    phone: Joi.string().pattern(/^[+]?[1-9]\\d{1,14}$/).optional()
};

// Pagination validation
const paginationSchema = Joi.object({
    page: Joi.number().integer().min(1).default(1),
    limit: Joi.number().integer().min(1).max(100).default(10),
    sort: Joi.string().valid('asc', 'desc').default('desc'),
    orderBy: Joi.string().optional()
});

// Validation middleware
const validate = (schema) => {
    return (req, res, next) => {
        const { error } = schema.validate(req.body);
        if (error) {
            return res.status(400).json({
                success: false,
                message: 'Validation error',
                errors: error.details.map(detail => ({
                    field: detail.path.join('.'),
                    message: detail.message
                }))
            });
        }
        next();
    };
};

module.exports = {
    commonSchemas,
    paginationSchema,
    validate
};
"""
        
        with open(os.path.join(utils_dir, "validators.js"), "w", encoding="utf-8") as f:
            f.write(validators_content)

    def _write_tests(self, root: str, erd_schema: ERDSchema) -> None:
        """Write test files"""
        tests_dir = os.path.join(root, "src", "tests")
        os.makedirs(tests_dir, exist_ok=True)
        
        for entity in erd_schema.entities:
            test_name = entity.name.lower()
            test_content = f"""const request = require('supertest');
const app = require('../app');
const {entity.name} = require('../models/{test_name}.model');

describe('{entity.name} API', () => {{
    beforeEach(async () => {{
        // Clean up database before each test
        await {entity.name}.destroy({{ where: {{}} }});
    }});

    describe('GET /api/{test_name}', () => {{
        it('should get all {entity.name.lower()}s', async () => {{
            const response = await request(app)
                .get('/api/{test_name}')
                .expect(200);
            
            expect(response.body.success).toBe(true);
            expect(Array.isArray(response.body.data)).toBe(true);
        }});
    }});

    describe('POST /api/{test_name}', () => {{
        it('should create a new {entity.name.lower()}', async () => {{
            const {entity.name.lower()}Data = {{
                // Add sample data based on entity attributes
                name: 'Test {entity.name}',
                email: 'test@example.com'
            }};
            
            const response = await request(app)
                .post('/api/{test_name}')
                .send({entity.name.lower()}Data)
                .expect(201);
            
            expect(response.body.success).toBe(true);
            expect(response.body.data).toHaveProperty('id');
        }});
    }});

    describe('GET /api/{test_name}/:id', () => {{
        it('should get {entity.name.lower()} by id', async () => {{
            // Create a test {entity.name.lower()}
            const {entity.name.lower()} = await {entity.name}.create({{
                name: 'Test {entity.name}',
                email: 'test@example.com'
            }});
            
            const response = await request(app)
                .get(`/api/{test_name}/${{{entity.name.lower()}.id}}`)
                .expect(200);
            
            expect(response.body.success).toBe(true);
            expect(response.body.data.id).toBe({entity.name.lower()}.id);
        }});
    }});
}});
"""
            
            with open(os.path.join(tests_dir, f"{test_name}.test.js"), "w", encoding="utf-8") as f:
                f.write(test_content)

    def _write_docs(self, root: str, erd_schema: ERDSchema) -> None:
        """Write API documentation"""
        docs_dir = os.path.join(root, "src", "docs")
        os.makedirs(docs_dir, exist_ok=True)
        
        # Generate OpenAPI/Swagger documentation
        openapi_content = f"""openapi: 3.0.0
info:
  title: {erd_schema.project_name} API
  description: Auto-generated API documentation
  version: 1.0.0
servers:
  - url: http://localhost:3000/api
    description: Development server
paths:
"""
        
        # Add paths for each entity
        for entity in erd_schema.entities:
            entity_name = entity.name.lower()
            openapi_content += f"""
  /{entity_name}:
    get:
      summary: Get all {entity.name.lower()}s
      tags:
        - {entity.name}
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/{entity.name}'
    post:
      summary: Create new {entity.name.lower()}
      tags:
        - {entity.name}
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/{entity.name}Input'
      responses:
        '201':
          description: Created successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                  data:
                    $ref: '#/components/schemas/{entity.name}'
  /{entity_name}/{{id}}:
    get:
      summary: Get {entity.name.lower()} by ID
      tags:
        - {entity.name}
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                  data:
                    $ref: '#/components/schemas/{entity.name}'
    put:
      summary: Update {entity.name.lower()}
      tags:
        - {entity.name}
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/{entity.name}Input'
      responses:
        '200':
          description: Updated successfully
    delete:
      summary: Delete {entity.name.lower()}
      tags:
        - {entity.name}
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: Deleted successfully
"""
        
        openapi_content += """
components:
  schemas:
"""
        
        # Add schemas for each entity
        for entity in erd_schema.entities:
            openapi_content += f"""
    {entity.name}:
      type: object
      properties:
        id:
          type: integer
          description: Unique identifier
"""
            for attr in entity.attributes:
                if attr.name != 'id':
                    openapi_content += f"        {attr.name}:\n"
                    if attr.data_type == DataType.INTEGER:
                        openapi_content += "          type: integer\n"
                    elif attr.data_type == DataType.STRING:
                        openapi_content += "          type: string\n"
                    elif attr.data_type == DataType.BOOLEAN:
                        openapi_content += "          type: boolean\n"
                    else:
                        openapi_content += "          type: string\n"
            
            openapi_content += f"""
    {entity.name}Input:
      type: object
      required:
"""
            for attr in entity.attributes:
                if not attr.is_nullable and attr.name != 'id':
                    openapi_content += f"        - {attr.name}\n"
            
            openapi_content += "      properties:\n"
            for attr in entity.attributes:
                if attr.name != 'id':
                    openapi_content += f"        {attr.name}:\n"
                    if attr.data_type == DataType.INTEGER:
                        openapi_content += "          type: integer\n"
                    elif attr.data_type == DataType.STRING:
                        openapi_content += "          type: string\n"
                    elif attr.data_type == DataType.BOOLEAN:
                        openapi_content += "          type: boolean\n"
                    else:
                        openapi_content += "          type: string\n"
        
        with open(os.path.join(docs_dir, "api-docs.yaml"), "w", encoding="utf-8") as f:
            f.write(openapi_content)

    def _sequelize_type(self, data_type: DataType) -> str:
        """Map DataType to Sequelize type"""
        mapping = {
            DataType.STRING: 'DataTypes.STRING',
            DataType.INTEGER: 'DataTypes.INTEGER',
            DataType.FLOAT: 'DataTypes.FLOAT',
            DataType.BOOLEAN: 'DataTypes.BOOLEAN',
            DataType.DATE: 'DataTypes.DATEONLY',
            DataType.DATETIME: 'DataTypes.DATE',
            DataType.TEXT: 'DataTypes.TEXT',
            DataType.JSON: 'DataTypes.JSONB',
            DataType.UUID: 'DataTypes.UUID',
            DataType.DECIMAL: 'DataTypes.DECIMAL',
            DataType.ENUM: 'DataTypes.ENUM',
            DataType.ARRAY: 'DataTypes.ARRAY',
            DataType.TIME: 'DataTypes.TIME',
            DataType.BLOB: 'DataTypes.BLOB',
            DataType.BINARY: 'DataTypes.BLOB',
            DataType.CHAR: 'DataTypes.CHAR',
            DataType.VARCHAR: 'DataTypes.STRING',
            DataType.LONGTEXT: 'DataTypes.TEXT',
            DataType.TINYINT: 'DataTypes.TINYINT',
            DataType.SMALLINT: 'DataTypes.SMALLINT',
            DataType.BIGINT: 'DataTypes.BIGINT',
            DataType.DOUBLE: 'DataTypes.DOUBLE',
            DataType.REAL: 'DataTypes.REAL',
            DataType.TIMESTAMP: 'DataTypes.DATE',
            DataType.YEAR: 'DataTypes.INTEGER',
            DataType.SET: 'DataTypes.ENUM',
        }
        return mapping.get(data_type, 'DataTypes.STRING')
